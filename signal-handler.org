#+TITLE: sending messages to Common Lisp (sbcl) programs from foreign code (e.g., shell) using `kill -s USR1 $pid`
#+AUTHOR: Oleg Shalaev
#+EMAIL:  oleg@chalaev.com
#+LaTeX_HEADER: \usepackage[english,russian]{babel}
#+LATEX_HEADER: \usepackage[letterpaper,hmargin={1.5cm,1.5cm},vmargin={1.3cm,2cm},nohead,nofoot]{geometry}

#+BEGIN_SRC lisp :tangle generated/signal-handler.lisp
(in-package :signal-handler)
(defvar hooks nil)
#+END_SRC

In order to distinguish log messages from this code we define special logger:
#+BEGIN_SRC lisp :tangle generated/signal-handler.lisp
(defun log(type format-str &rest params)
  (apply #'sl:log (cons type (cons (concat "SH " format-str) params))))
#+END_SRC

* OS interface
This is a system function, so we have to use ~cffi~:
#+BEGIN_SRC lisp :tangle generated/signal-handler.lisp
(cffi:defcstruct saType ; typedef for sigaction
  (handler :pointer)
  (sigaction :pointer); unused
  (mask  :unsigned-long)
  (flags  :int))
#+END_SRC
where mask is ~SA_SIGINFO~ mask of signals which should be blocked during execution of the signal handler,
and flags modify the behaviour of the signal handling process.

For example, a shell-command =kill-s USR1 $pid= corresponds to ~signum=10~.
We are going to focus on this signal only and ignore the others (e.g., =USR2= or =HUP=):

External code is supposed to use some sort of =directory-lock= environment that 
1. creates a lock directory,
2. leaves a message there, and
3. before leaving the lock-environment, send ~kill~ signal to our lisp code.

So the first thing that our =sighandler= is going to check is if any of the lock-directories were created.
(There can actually be several of these named =active-hooks= below, and they all need to be addressed.)

Now once we have defined the callback by =cffi:defcallback=, we can use it (not vice versa – this order is important!)
#+BEGIN_SRC lisp :tangle generated/signal-handler.lisp
(let(started lock-dir)
(flet((pid-FN ()
  (ifn lock-dir (log sl:error "pid-FN: undefined lock-dir")
     (merge-pathnames "pid" lock-dir))))
(defun start(&optional (root-directory (uiop:temporary-directory)))
(setf lock-dir (uiop:ensure-directory-pathname root-directory))
(ensure-directories-exist lock-dir)
;;(log sl:debug "lock-dir= ~S" lock-dir); lock-dir= #P"/tmp/sbcl.lock/"
(iff started (log sl:warning "will not restart already active sigkill handler")
#+END_SRC
Defining callback function: =cffi:defcallback= immediately compiles its argument (the specified function) →
#+BEGIN_SRC lisp :tangle generated/signal-handler.lisp
(cffi:defcallback sighandler :void ((signum :int) (info :pointer) (ptr :pointer))
  (declare(integer signum))
  (when (= 10 signum)
    (dolist(hook hooks)
      (let((hook-dir(uiop:ensure-directory-pathname(merge-pathnames (car hook) lock-dir))))
        (when(uiop:directory-exists-p hook-dir)
          (funcall (cdr hook) hook-dir)
	  T))))); must return T
#+END_SRC
← I guess we need this =T= to let the system know that =kill= signal was properly handled.
Without this =T= further kill signals will be blocked.

The hook function =(cdr hook)= will now probably
1. read some file in the directory =hook-dir=,
2. perform the request encoded in this file, and
3. erase this file afterwards to let client(s) know that the system is ready to accept new requests.

This was the end of the kill-acceptor code named =sighandler=. Now let us activate it:
#+BEGIN_SRC lisp :tangle generated/signal-handler.lisp
(cffi:with-foreign-object (act '(:struct saType))
  (setf (cffi:foreign-slot-value act '(:struct saType) 'handler) (cffi:callback sighandler))
  (setf (cffi:foreign-slot-value act '(:struct saType) 'mask) iolib.syscalls:sa-siginfo)
  (iolib.syscalls:sigaction iolib.syscalls:sigusr1 act (cffi-sys:null-pointer)))
#+END_SRC

Sending kill signals has collateral effect – as if we evaluated =(bt:condition-notify stop-the-server)=.

Let the killers know whom to kill by creating ~pid~ file:
#+BEGIN_SRC lisp :tangle generated/signal-handler.lisp
(echo-to-file (pid-FN) (format nil "~d ok" (sb-posix:getpid)))
(log sl:info ":signal-handler is now ready to treat kill signals.")
(setf started t)))
(defun stop()
  (delete-file (pid-FN))
  (log sl:info "erased ~a" (pid-FN)))))
#+END_SRC

I noticed that log messages were temporarily blocked with this code, and suspect that
this may happen due to the wrong (too strict) value of =iolib.syscalls:sa-siginfo= above.

* Handlers: register and forget
#+BEGIN_SRC lisp :tangle generated/signal-handler.lisp
(defun register (name hook-function)
(declare (string name))
#+END_SRC
← =hook-function= (or handler) must return =T=; otherwise further signals are blocked.

It will be evaluated when someone
1. creates a lock directory =name=, and then
2. sends the kill signal:
#+BEGIN_SRC lisp :tangle generated/signal-handler.lisp
(if(find name hooks :key  #'car)
 (log sl:warning "will not re-register already active hook for ~s" name)
 (push (cons name hook-function) hooks)))
#+END_SRC
Forgetting hooks:
#+BEGIN_SRC lisp :tangle generated/signal-handler.lisp
(defun forget(name)
  (drop-if name hooks :key #'car :test #'string=))
(defun forget-all()
  (setf hooks nil))
#+END_SRC

* Example
#+BEGIN_SRC lisp :tangle generated/example.lisp
(in-package :signal-handler/example)
(defun log (type &rest message)
    (apply #'sl:log
      (cons type (cons (concat "SHE " (car message)) (cdr message)))))
#+END_SRC

#+BEGIN_SRC lisp :tangle generated/example.lisp
(defvar working nil)
(defvar stop-the-server (bt:make-condition-variable))
(defun stop() 
  (setf working nil)
  (bt:condition-notify stop-the-server))
#+END_SRC

Every time the kill-signal is sent, the following (toy) function will be called.
It is important that =wachter= finishes as fast as possible; otherwise we risk =Segmantation Fault= error:
#+BEGIN_SRC lisp :tangle generated/example.lisp
(defun wachter(request-directory)
  "An example kill-signal handler. Its argument is a message from the killer."
(let((FN(merge-pathnames "by" request-directory)) (work-time(/ (random 50) 100.0)))
(with-open-file(s FN)
(ifn-let((message(read-line s nil))) (log sl:error "could not find the file ~a" FN)
(iff(string= message "bye") (progn (delete-file FN) (stop))
(log sl:info "my killer told me: ~s, now let me digest that..." message)
(sleep work-time)
(log sl:info "I worked hard for ~A seconds, and now I am ready for more requests" work-time)
(delete-file FN))))))
#+END_SRC
← let everyone now we are ready for new requests

The compilation may fail if we move any code outside of the =main= function:
#+BEGIN_SRC lisp :tangle generated/example.lisp
(defun main()
(setf sl:out-streams (list *standard-output*))
(setf working t)
(sl:start); starting the log server
(log sl:info "starting kill-signal server...")
(sh:start (make-pathname :directory '(:absolute "tmp"); ← have to use /tmp because cannot write to /var/lock
:name "sbcl" :type "lock"))
#+END_SRC
← specifies the directory where
1. one can find PID for killing, and
2. where the messages for the lisp code should be left.

#+BEGIN_SRC lisp :tangle generated/example.lisp
(sh:register "acceptor" #'wachter)
(log sl:info "will accept messages until someone tells me \"bye\"")
#+END_SRC
[[The thread...may also resume if]] interrupted by some external event or in other implementation-dependent circumstances: the caller
must always test on waking that there is threading to be done, instead of assuming that it can go ahead.

In other words, our lock is not absolute and can be unlocked for some unexpected (and uncontrolled) reason.
This is why we have to write a loop:
#+BEGIN_SRC lisp :tangle generated/example.lisp
(loop while working do
(let((SL-lock(bt:make-lock)))
  (bt:with-lock-held(SL-lock)
  (bt:condition-wait stop-the-server SL-lock)
  (log sl:debug "unlocked"))))
#+END_SRC
← if the unlocking was not authorized, we will lock it again and again in the loop.
Otherwise the lock was released due to the 

#+BEGIN_SRC lisp :tangle generated/example.lisp
(log sl:info "stopping the server")
(sh:stop); stopping signal handler
(sl:stop)); stopping log server after flusshing remaining log messages
#+END_SRC

* Usage
For this section we need compiled binary =example.bin= produced by =make=, see [[file:Makefile][Makefile]].
** Terminal (shell)
First of all let us ensure that =example.bin= started and created the file with its PID:
#+BEGIN_SRC shell :tangle generated/tell :shebang "#!/bin/bash"
dir=/tmp/sbcl.lock
PIDfile=$dir/pid
lock=$dir/acceptor
message=$lock/by
#+END_SRC

=get_PID= will wait until the binary will launch and report its PID:
#+BEGIN_SRC shell :tangle generated/tell
function get_PID {
local i=20
local r
while [ ! -f $1 ]  && [ $i -ge 0 ] || r=`awk '{if($2=="ok"){print $1}}' $1` && [ -z $r ]  ; do
	i=$(($i - 1))
	sleep .1
done
echo $r
}
#+END_SRC
where we want to be sure that the first argument (before "ok") is written to the file =$PIDfile= completely.

#+BEGIN_SRC shell :tangle generated/tell
lispPID=$(get_PID $PIDfile)
echo "lisp code says that its PID=$lispPID"
#+END_SRC

Now in case someone else is talking to =example.bin=, let us wait until (s)he removes the lock (that is, deletes the directory):
#+BEGIN_SRC shell :tangle generated/tell
function send_message {
local i=20
while  [ $i -ge 0 ] && ! (mkdir "$lock" 2>/dev/null && echo "$1" > $message) ; do
    echo "$((21-$i))th attempt to mkdir failed -- waiting until the lock is removed"
    i=$(($i - 1))
    sleep .1
done
#+END_SRC
Let us now tell the LISP code (=example.bin=) to read the message:
#+BEGIN_SRC shell :tangle generated/tell
kill -s USR1 $lispPID
#+END_SRC
=example.bin= will let us know that the message was received by removing the file:
#+BEGIN_SRC shell :tangle generated/tell
echo "Now let us ensure that our message has been delivered."
j=20
while [ -f $message ]  && [ $j -ge 0 ] ; do
    echo "$((21-$j))th check: waiting for the LISP code that must delete $message"
    j=$(($j - 1))
    sleep .1
done
rmdir $lock
if [ $j -ge 0 ]; then
    echo "After $((40-$i-$j))/10 seconds, the message was delivered."
else
    echo "The message was NOT delivered!"
fi
}
#+END_SRC
Now let as send some messages:
#+BEGIN_SRC shell :tangle generated/tell
echo ""
send_message "hello"
sleep 1
echo ""
send_message "I love you"
sleep 1
echo ""
send_message "bye"
#+END_SRC

** emacs
*To be written*

For killing use
#+BEGIN_SRC elisp
(signal-process PID 'sigusr1)
#+END_SRC

BTW, ~DBus~ is available in elisp:
#+BEGIN_SRC elisp
(featurep 'dbusbind)
#+END_SRC

#+RESULTS:
: t
