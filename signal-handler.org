#+TITLE: sending messages to Common Lisp (sbcl) programs from foreign code (e.g., shell) using `kill -s USR1 $pid`
#+AUTHOR: Oleg Shalaev
#+EMAIL:  oleg@chalaev.com
#+LaTeX_HEADER: \usepackage[english,russian]{babel}
#+LATEX_HEADER: \usepackage[letterpaper,hmargin={1.5cm,1.5cm},vmargin={1.3cm,2cm},nohead,nofoot]{geometry}

#+BEGIN_SRC lisp :tangle generated/signal-handler.lisp
(defvar *started* nil)
(defvar hooks nil)
(defvar *clients* nil)
#+END_SRC
← list of watch functions are registered by clients.

In order to distinguish log messages from this code we define special logger:
#+BEGIN_SRC lisp :tangle generated/signal-handler.lisp
(defun log(type format-str &rest params)
  (apply #'sl:log (cons type (cons (concat "SH " format-str) params))))
#+END_SRC

* OS interface
This is a system function, so we have to use ~cffi~:
#+BEGIN_SRC lisp :tangle generated/signal-handler.lisp
(cffi:defcstruct saType ; typedef for sigaction
  (handler :pointer)
  (sigaction :pointer); unused
  (mask  :unsigned-long)
  (flags  :int))
#+END_SRC
where mask is ~SA_SIGINFO~ mask of signals which should be blocked during execution of the signal handler,
and flags modify the behaviour of the signal handling process.

For example, a shell-command =kill-s USR1 $pid= corresponds to ~signum=10~.
We are going to focus on this signal only and ignore the others (e.g., USR2 or HUP):

External code is supposed to use some sort of =directory-lock= environment that 
1. creates a lock directory,
2. leaves a message there, and
3. before leaving the lock-environment, send ~kill~ signal to our lisp code.

So actually the first thing that our =sighandler= is going to check is
if any of the lock-directories were actually created.
(There can actually be several of these named =active-hooks= below, and they all need to be addressed.)

=cffi:defcallback= immediately compiles its argument (the specified function):
#+BEGIN_SRC lisp :tangle generated/signal-handler.lisp
(defvar lock-dir nil)
(cffi:defcallback sighandler :void ((signum :int) (info :pointer) (ptr :pointer))
  (declare(integer signum))
;;(ifn lock-dir (log sl:error "lock-dir is undefined")
  (when (= 10 signum)
    (needs ((active-hooks (remove-if-not #'(lambda(h) (directory (merge-paths lock-dir (car h)))) hooks) (log sl:debug "hook not found")))
	   (dolist (hook active-hooks)
	     (let ((hf (cdr hook)) (FN (merge-paths lock-dir (car hook) "by")))
#+END_SRC
← the file name is always the same: "by", but its (lock) directory name is unique for each service.
#+BEGIN_SRC lisp :tangle generated/signal-handler.lisp
(log sl:debug "found the directory ~a, will now read the file" (car hook))
(with-open-file(s FN :if-does-not-exist :create)
  (ifn-let((mes(read-line s nil))) (log sl:error "could not find the file ~a" FN)
    (funcall hf mes)
    (log sl:debug "received the message ~s, erasing the file ~a" mes FN)))
(delete-file FN))))))
#+END_SRC
By erasing the file we let the message sender (directory locker) know that the message was received.
This was the end of the kill-acceptor code.

Now once we have defined the callback by =cffi:defcallback=, we can use it (not vice versa – this order is important!)
#+BEGIN_SRC lisp :tangle generated/signal-handler.lisp
(defun pid-FN()
(ifn lock-dir (log sl:error "pid-FN: undefined lock-dir")
(merge-paths lock-dir "pid")))
(defun start(&optional (root-directory (uiop:temporary-directory)))
(iff *started* (log sl:debug "already started, won't start for the second time")
(setf lock-dir (ensure-directories-exist (uiop:ensure-directory-pathname root-directory)))
(cffi:with-foreign-object (act '(:struct saType))
  (setf (cffi:foreign-slot-value act '(:struct saType) 'handler) (cffi:callback sighandler))
  (setf (cffi:foreign-slot-value act '(:struct saType) 'mask) iolib.syscalls:sa-siginfo)
  (iolib.syscalls:sigaction iolib.syscalls:sigusr1 act (cffi-sys:null-pointer)))
#+END_SRC
Let the killers know whom to kill by creating ~pid~ file:
#+BEGIN_SRC lisp :tangle generated/signal-handler.lisp
(echo-to-file (pid-FN) (format nil "~d ok" (sb-posix:getpid))))
(log sl:info ":signal-handler is now ready to treat kill signals.")
(setf *started* t))
(defun stop()
(delete-file (pid-FN))
(log sl:info "erased ~a" (pid-FN)))
#+END_SRC
I noticed that log messages were temporarily blocked with this code, and suspect that
this may happen due to the wrong (too strict) value of =iolib.syscalls:sa-siginfo=.

* Handlers: register and forget
#+BEGIN_SRC lisp :tangle generated/signal-handler.lisp
(defun register (name hook-function)
#+END_SRC
← =hook-function= (or handler) must return =T=; otherwise further signals are blocked.

It will be evaluated when someone
1. creates a lock directory =name=, and then
2. sends the kill signal:
#+BEGIN_SRC lisp :tangle generated/signal-handler.lisp
(declare (string name))
(if(member name (mapcar #'car hooks))
 (log sl:error "hook for ~s is already registered" name)
 (push (cons name hook-function) hooks)))
#+END_SRC
Forgetting hooks:
#+BEGIN_SRC lisp :tangle generated/signal-handler.lisp
(defun forget(name)
  (drop-if name hooks :key #'car :test #'string=))
(defun forget-all()
  (setf hooks nil))
#+END_SRC

* Example
#+BEGIN_SRC lisp :tangle generated/example.lisp
(defun logE (type &rest message)
    (apply #'sl:log
      (cons type (cons (concat "SHE " (car message)) (cdr message)))))
#+END_SRC

Every time the kill-signal is sent, the following (toy) function will be called:
#+BEGIN_SRC lisp :tangle generated/example.lisp
(defun wachter(message)
  "An example kill-signal handler. Its argument is a message from the killer."
  (logE sl:info "my killer told me: ~s" message) T)
#+END_SRC
←  handler must return T.

Note that the compilation fails if we move any code outside of the =main= function:
#+BEGIN_SRC lisp :tangle generated/example.lisp
(defvar time-interval 3)
(defun main()
(sh:start (merge-pathnames (make-pathname :directory "tmp")  "sbcl.lock"))
#+END_SRC
← won't work without this command.

#+BEGIN_SRC lisp :tangle generated/example.lisp
(sh:register "acceptor" #'wachter)
(logE sl:debug "started simple-handler service")
#+END_SRC

#+BEGIN_SRC lisp :tangle generated/example.lisp
(setf sl:out-streams (list *standard-output*))
(logE sl:info "will accept messages for the next ~d seconds" time-interval)
(sleep time-interval)
(logE sl:info "time is up, hook is removed, messages are ignored from now")
(sleep 1)
(sh:stop))
#+END_SRC
← the last command is essential – it cleans up.

* Usage
For this section we need compiled binary =example.bin= produced by =make=, see [[file:Makefile][Makefile]].
** Terminal (shell)
First of all let us ensure that =example.bin= started and created the file with its PID:
#+BEGIN_SRC shell :tangle generated/tell :shebang "#!/bin/bash"
dir=/tmp/sbcl.lock
PIDfile=$dir/pid
lock=$dir/acceptor
message=$lock/by
#+END_SRC

#+BEGIN_SRC shell :tangle generated/tell
function waitForFile {
local i=20
local r
while [ ! -f $1 ]  && [ $i -ge 0 ] || r=`awk '{if($2=="ok"){print $1}}' $1` && [ -z $r ]  ; do
	i=$(($i - 1))
	sleep .1
done
echo $r
}
lispPID=`waitForFile $PIDfile`
if [ -z $lispPID ]; then
    echo "lisp code did not create PID file, exiting"
    exit -1
else
#+END_SRC
where we want to be sure that the first argument (before "ok") is written to the file =$PIDfile= completely.

Now in case someone else is talking to =example.bin=, let us wait until (s)he removes the lock (that is, deletes the directory):
#+BEGIN_SRC shell :tangle generated/tell
echo "lisp code says that its PID=$lispPID"
i=20
while  [ $i -ge 0 ] && ! (mkdir "$lock" 2>/dev/null && echo "Let me tell you something: the time now is `date`" > $message) ; do
    echo "$((21-$i))th attempt to mkdir failed -- waiting until the lock is removed"
    i=$(($i - 1))
    sleep .1
done
#+END_SRC

Let us now tell the LISP code (=example.bin=) to read the message:
#+BEGIN_SRC shell :tangle generated/tell
echo "kill -s USR1 $lispPID"
kill -s USR1 $lispPID
#+END_SRC
=example.bin= will let us know that the message was received by removing the file:
#+BEGIN_SRC shell :tangle generated/tell
echo "Now let us ensure that our message has been delivered."
j=20
while [ -f $message ]  && [ $j -ge 0 ] ; do
    echo "$((21-$j))th check: waiting for the LISP code that must delete $message"
    j=$(($j - 1))
    sleep .1
done
rmdir $lock
if [ $j -ge 0 ]; then
    echo "After $((40-$i-$j))/10 seconds, the message was delivered."
else
    echo "The message was NOT delivered!"
fi
#+END_SRC
At this point we could send more messages by creating the file =$message= again and sending the =kill= signal.

Or we could just finish the conversation by removing the lock (directory):
#+BEGIN_SRC shell :tangle generated/tell
echo "all done, ready for more messages"
fi
#+END_SRC
** emacs
*To be written*

For killing use
#+BEGIN_SRC elisp
(signal-process PID 'sigusr1)
#+END_SRC

BTW, ~DBus~ is available in elisp:
#+BEGIN_SRC elisp
(featurep 'dbusbind)
#+END_SRC
