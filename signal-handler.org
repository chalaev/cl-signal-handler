#+TITLE: sending messages to Common Lisp (sbcl) programs from foreign code (e.g., shell) using `kill -s USR1 $pid`
#+AUTHOR: Oleg Shalaev
#+EMAIL:  oleg@chalaev.com
#+LaTeX_HEADER: \usepackage[english,russian]{babel}
#+LATEX_HEADER: \usepackage[letterpaper,hmargin={1.5cm,1.5cm},vmargin={1.3cm,2cm},nohead,nofoot]{geometry}

#+BEGIN_SRC lisp :tangle generated/signal-handler.lisp
(defvar *started* nil)
(defvar hooks nil)
(defvar *clients* nil)
#+END_SRC
← list of watch functions are registered by clients.

In order to distinguish log messages from this code we define special logger:
#+BEGIN_SRC lisp :tangle generated/signal-handler.lisp
(defun log(type format-str &rest params)
  (apply #'sl:log (cons type (cons (concat "SH " format-str) params))))
#+END_SRC

* OS interface
This is a system function, so we have to use ~cffi~:
#+BEGIN_SRC lisp :tangle generated/signal-handler.lisp
(cffi:defcstruct saType ; typedef for sigaction
  (handler :pointer)
  (sigaction :pointer); unused
  (mask  :unsigned-long)
  (flags  :int))
#+END_SRC
where mask is ~SA_SIGINFO~ mask of signals which should be blocked during execution of the signal handler,
and flags modify the behaviour of the signal handling process.

For example, a shell-command =kill-s USR1 $pid= corresponds to ~signum=10~.
We are going to focus on this signal only and ignore the others (e.g., USR2 or HUP):

External code is supposed to use some sort of =directory-lock= environment that 
1. creates a lock directory,
2. leaves a message there, and
3. before leaving the lock-environment, send ~kill~ signal to our lisp code.

So the first thing that our =sighandler= is going to check is if any of the lock-directories were created.
(There can actually be several of these named =active-hooks= below, and they all need to be addressed.)

=cffi:defcallback= immediately compiles its argument (the specified function):
#+BEGIN_SRC lisp :tangle generated/signal-handler.lisp
(defvar lock-dir nil)
(cffi:defcallback sighandler :void ((signum :int) (info :pointer) (ptr :pointer))
  (declare(integer signum))
;;(ifn lock-dir (log sl:error "lock-dir is undefined")
  (when (= 10 signum)
    (needs ((active-hooks (remove-if-not #'(lambda(h) (directory (merge-paths lock-dir (car h)))) hooks) (log sl:debug "hook not found")))
	   (dolist (hook active-hooks)
	     (let ((hf (cdr hook)) (FN (merge-paths lock-dir (car hook) "by")))
#+END_SRC
← the file name is always the same: "by", but its (lock) directory name is unique for each service.
#+BEGIN_SRC lisp :tangle generated/signal-handler.lisp
(log sl:debug "found the directory ~a, will now read the file" (car hook))
(with-open-file(s FN :if-does-not-exist :create)
  (ifn-let((mes(read-line s nil))) (log sl:error "could not find the file ~a" FN)
    (funcall hf mes)
    (log sl:debug "received the message ~s, erasing the file ~a" mes FN)))
(delete-file FN))))))
#+END_SRC
By erasing the file we let the message sender (directory locker) know that the message was received.
This was the end of the kill-acceptor code.

Now once we have defined the callback by =cffi:defcallback=, we can use it (not vice versa – this order is important!)
#+BEGIN_SRC lisp :tangle generated/signal-handler.lisp
(defun pid-FN()
(ifn lock-dir (log sl:error "pid-FN: undefined lock-dir")
(merge-paths lock-dir "pid")))
(defun start(&optional (root-directory (uiop:temporary-directory)))
(iff *started* (log sl:debug "sigkill handler already started")
(setf lock-dir (ensure-directories-exist (uiop:ensure-directory-pathname root-directory)))
(cffi:with-foreign-object (act '(:struct saType))
  (setf (cffi:foreign-slot-value act '(:struct saType) 'handler) (cffi:callback sighandler))
  (setf (cffi:foreign-slot-value act '(:struct saType) 'mask) iolib.syscalls:sa-siginfo)
  (iolib.syscalls:sigaction iolib.syscalls:sigusr1 act (cffi-sys:null-pointer)))
#+END_SRC
Let the killers know whom to kill by creating ~pid~ file:
#+BEGIN_SRC lisp :tangle generated/signal-handler.lisp
(echo-to-file (pid-FN) (format nil "~d ok" (sb-posix:getpid))))
(log sl:info ":signal-handler is now ready to treat kill signals.")
(setf *started* t))
(defun stop()
(delete-file (pid-FN))
(log sl:info "erased ~a" (pid-FN))
(setf *started* nil))
#+END_SRC
I noticed that log messages were temporarily blocked with this code, and suspect that
this may happen due to the wrong (too strict) value of =iolib.syscalls:sa-siginfo=.

* Handlers: register and forget
#+BEGIN_SRC lisp :tangle generated/signal-handler.lisp
(defun register (name hook-function)
#+END_SRC
← =hook-function= (or handler) must return =T=; otherwise further signals are blocked.

It will be evaluated when someone
1. creates a lock directory =name=, and then
2. sends the kill signal:
#+BEGIN_SRC lisp :tangle generated/signal-handler.lisp
(declare (string name))
(if(member name (mapcar #'car hooks))
 (log sl:error "hook for ~s is already registered" name)
 (push (cons name hook-function) hooks)))
#+END_SRC
Forgetting hooks:
#+BEGIN_SRC lisp :tangle generated/signal-handler.lisp
(defun forget(name)
  (drop-if name hooks :key #'car :test #'string=))
(defun forget-all()
  (setf hooks nil))
#+END_SRC

* Example
#+BEGIN_SRC lisp :tangle generated/example.lisp
(defun logE (type &rest message)
    (apply #'sl:log
      (cons type (cons (concat "SHE " (car message)) (cdr message)))))
#+END_SRC

Every time the kill-signal is sent, the following (toy) function will be called:
#+BEGIN_SRC lisp :tangle generated/example.lisp
(defvar working nil)
(defvar stop-the-server (bt:make-condition-variable))
(defun stop() 
  (setf working nil)
  (bt:condition-notify stop-the-server))

(defun wachter(message)
  "An example kill-signal handler. Its argument is a message from the killer."
(logE sl:info "my killer told me: ~s" message)
(when (string= message "bye")
  (logE sl:info "stopping the server")
  (stop))
 T)
#+END_SRC
←  handler must return T.

The compilation may fail if we move any code outside of the =main= function:
#+BEGIN_SRC lisp :tangle generated/example.lisp
(defun main()
(setf sl:out-streams (list *standard-output*))
(setf working t)
(sl:start); starting the log server
(logE sl:info "starting kill-signal server")
(sh:start (make-pathname :directory '(:absolute "tmp")  :name "sbcl" :type "lock"))
#+END_SRC
← specifies the directory where
1. one can find PID for killing, and
2. where the messages for the lisp code should be left.

#+BEGIN_SRC lisp :tangle generated/example.lisp
(sh:register "acceptor" #'wachter)
(logE sl:info "will accept messages until someone tells me \"bye\"")
#+END_SRC
[[The thread...may also resume if]] interrupted by some external event or in other implementation-dependent circumstances: the caller
must always test on waking that there is threading to be done, instead of assuming that it can go ahead.

In other words, our lock is not absolute and can be unlocked for some unexpected (and uncontrolled) reason.
This is why we have to write a loop:
#+BEGIN_SRC lisp :tangle generated/example.lisp
(loop while working do
(let((SL-lock(bt:make-lock)))
  (bt:with-lock-held(SL-lock)
  (bt:condition-wait stop-the-server SL-lock)
  (logE sl:debug "unlocked"))))
#+END_SRC
← if the unlocking was not authorized, we will lock it again and again in the loop.

#+BEGIN_SRC lisp :tangle generated/example.lisp
(logE sl:info "stopping the server")
(sh:stop); stopping signal handler
(sl:stop)); stopping log server after flusshing remaining log messages
#+END_SRC

* Usage
For this section we need compiled binary =example.bin= produced by =make=, see [[file:Makefile][Makefile]].
** Terminal (shell)
First of all let us ensure that =example.bin= started and created the file with its PID:
#+BEGIN_SRC shell :tangle generated/tell :shebang "#!/bin/bash"
dir=/tmp/sbcl.lock
PIDfile=$dir/pid
lock=$dir/acceptor
message=$lock/by
#+END_SRC

=get_PID= will wait until the binary will launch and report its PID:
#+BEGIN_SRC shell :tangle generated/tell
function get_PID {
local i=20
local r
while [ ! -f $1 ]  && [ $i -ge 0 ] || r=`awk '{if($2=="ok"){print $1}}' $1` && [ -z $r ]  ; do
	i=$(($i - 1))
	sleep .1
done
echo $r
}
#+END_SRC
where we want to be sure that the first argument (before "ok") is written to the file =$PIDfile= completely.

#+BEGIN_SRC shell :tangle generated/tell
lispPID=$(get_PID $PIDfile)
echo "lisp code says that its PID=$lispPID"
#+END_SRC

Now in case someone else is talking to =example.bin=, let us wait until (s)he removes the lock (that is, deletes the directory):
#+BEGIN_SRC shell :tangle generated/tell
function send_message {
local i=20
while  [ $i -ge 0 ] && ! (mkdir "$lock" 2>/dev/null && echo "$1" > $message) ; do
    echo "$((21-$i))th attempt to mkdir failed -- waiting until the lock is removed"
    i=$(($i - 1))
    sleep .1
done
#+END_SRC
Let us now tell the LISP code (=example.bin=) to read the message:
#+BEGIN_SRC shell :tangle generated/tell
kill -s USR1 $(get_PID $PIDfile)
#+END_SRC
=example.bin= will let us know that the message was received by removing the file:
#+BEGIN_SRC shell :tangle generated/tell
echo "Now let us ensure that our message has been delivered."
j=20
while [ -f $message ]  && [ $j -ge 0 ] ; do
    echo "$((21-$j))th check: waiting for the LISP code that must delete $message"
    j=$(($j - 1))
    sleep .1
done
rmdir $lock
if [ $j -ge 0 ]; then
    echo "After $((40-$i-$j))/10 seconds, the message was delivered."
else
    echo "The message was NOT delivered!"
fi
}
#+END_SRC
Now let as send some messages:
#+BEGIN_SRC shell :tangle generated/tell
echo ""
send_message "hello"
sleep 1
echo ""
send_message "I love you"
sleep 1
echo ""
send_message "bye"
#+END_SRC

** emacs
*To be written*

For killing use
#+BEGIN_SRC elisp
(signal-process PID 'sigusr1)
#+END_SRC

BTW, ~DBus~ is available in elisp:
#+BEGIN_SRC elisp
(featurep 'dbusbind)
#+END_SRC

#+RESULTS:
: t
